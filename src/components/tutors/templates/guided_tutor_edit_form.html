{% extends "base.html" %}

{% block extrahead %}
  <script type="module">
    // For rendering names and questions
    import markdownIt from 'https://cdn.jsdelivr.net/npm/markdown-it@14/+esm';
    const md = markdownIt();

    document.addEventListener('alpine:init', () => {
      const orig_tutor = {{ item | tojson }};  // store so we can reset the entire form
      Alpine.data('tutor_editor', () => ({
        tutor: null,
        loading: null,

        // Modal state for editing lists of items
        editItems: null,
        editingObjectives: false,
        tempItems: null,
        drag_index: null,
        objectiveTemplate: {name: '', questions: []},  // to copy for objectives added in the UI

        init() {
          this.reset_form();
        },
        reset_form() {
          this.tutor = structuredClone(orig_tutor);
        },

        render(markdown) {
          return md.render(markdown);
        },

        get hasObjectives() {
          return this.tutor.objectives.length;
        },
        get hasQuestions() {
          return this.hasObjectives && this.tutor.objectives.some(obj => obj.questions.length);
        },

        async _fetchGeneratedObjectives(url, loadingKey) {
          const form = this.$refs.tutor_form;

          // validate and report issues in form (if any) before proceeding
          if (!form.reportValidity()) {
            return;
          }

          this.loading = loadingKey;
          try {
            // build formdata to send via fetch
            const formData = new URLSearchParams(new FormData(form));

            // start the request
            const response = await fetch(url, { method: 'POST', body: formData });

            if (!response.ok) {
              const text = await response.text();
              alert(`An error occurred: ${text}`);
              return;
            }

            const newObjectives = await response.json();
            this.tutor.objectives = newObjectives;
          } catch (error) {
            alert(`An error occurred: ${error}`);
          } finally {
            this.loading = null;
          }
        },

        async generateObjectives() {
          await this._fetchGeneratedObjectives('{{ url_for('class_config.table.guided.generate_objectives') }}', 'objectives');
        },
        async generateQuestions() {
          await this._fetchGeneratedObjectives('{{ url_for('class_config.table.guided.generate_questions') }}', 'questions');
        },

        // Item editor modal methods
        openItemEditor(editItems, editTitle, editingObjectives) {
          this.editItems = editItems;
          this.editingObjectives = editingObjectives;
          this.editTitle = editTitle;
          // Get raw / unproxied data for cloning
          const rawItems = Alpine.raw(editItems);
          // Clone so we can cancel the edit without updating the original
          this.tempItems = structuredClone(rawItems);
          this.$refs.itemEditorModal.showModal();
        },
        saveItems() {
          // replace contents of array being edited with results of dialog
          this.editItems.splice(0, this.editItems.length, ...this.tempItems);
          this.$refs.itemEditorModal.close();
        },
        resetItemEditor() {
          // triggered by @close on the dialog element
          this.editItems = null;
          this.editTitle = null;
          this.tempItems = null;
        },

        // Drag and drop methods for item editor
        dragstart(index, event) {
          // only allow drag if over the drag handle
          const dragElement = event.target.querySelector("[data-drag-handle]");
          // use :hover match to detect if cursor is within the element
          if (dragElement === null || !dragElement.matches(":hover")) { event.preventDefault(); return; }
          this.drag_index = index;
        },
        dragenter(index) {
          if (this.drag_index === null || index === this.drag_index) { return; }
          const draggedItem = this.tempItems.splice(this.drag_index, 1)[0];
          this.tempItems.splice(index, 0, draggedItem);
          this.drag_index = index;
        },
        dragend() {
          this.drag_index = null;
        },
      }));

      Alpine.data('docUploader', () => ({
        processing: false,
        progress: 0,
        statusText: '',
        error: '',
        origWordCount: 0,
        wordCount: 0,

        // state for the editing modal
        editingFilename: null,

        async handleFileSelect(event) {
          const file = event.target.files[0];
          if (!file) {
            this.clearFile();
            return;
          }

          // Find the matching handler using destructuring assignment
          const fileName = file.name.toLowerCase();
          const entry = Object.entries(this.fileHandlers)
            .find(([ext, _handler]) => fileName.endsWith(ext));

          if (!entry) {
            this.clearFile();
            this.error = 'Unsupported file type. Please upload a PDF or DOCX file.';
            return;
          }

          const [_, handler] = entry;

          try {
            await this.extractText(file, handler);
          } catch (error) {
            this.error = `Failed to extract text from ${handler.displayName} file: ${error.message}`;
            console.error('Text extraction error:', error);
          }
        },

        // File type handlers using strategy pattern
        fileHandlers: {
          '.pdf': {
            displayName: 'PDF',
            extract: async (file, progressCallback) => {
              // Dynamically import PDF.js
              progressCallback(5, 'Loading PDF library...');
              const pdfjsLib = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4/+esm');
              pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4/build/pdf.worker.min.mjs';

              const arrayBuffer = await file.arrayBuffer();
              progressCallback(15, 'Parsing PDF structure...');

              const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
              const numPages = pdf.numPages;

              let fullText = '';

              for (let i = 1; i <= numPages; i++) {
                progressCallback(15 + (i / numPages) * 75, 
                  `Extracting text from page ${i} of ${numPages}...`);

                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent({
                  normalizeWhitespace: true
                });

                // Simple approach: add line breaks based on hasEOL flag
                let pageText = '';
                for (const item of textContent.items) {
                  pageText += item.str;
                  if (item.hasEOL) {
                    pageText += '\n';
                  } else {
                    // Add space if the next item doesn't start immediately
                    pageText += ' ';
                  }
                }

                fullText += pageText + '\n\n';
              }

              return fullText;
            }
          },
          '.docx': {
            displayName: 'DOCX',
            extract: async (file, progressCallback) => {
              // Dynamically import mammoth.js
              progressCallback(5, 'Loading DOCX library...');
              const mammoth = await import('https://cdn.jsdelivr.net/npm/mammoth@1/+esm');

              progressCallback(30, 'Parsing DOCX structure...');

              const arrayBuffer = await file.arrayBuffer();
              const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });

              return result.value;
            }
          }
        },

        // Helper to process document text (count words, truncate, store)
        processDocumentText(rawText) {
          // Clean up the text
          let text = rawText.trim();

          // Count words
          this.origWordCount = text.split(/\s+/).filter(word => word.length > 0).length;

          // Truncate if too long (50k words limit)
          if (this.origWordCount > 50000) {
            const matches = text.match(/((?:\S+\s+){1,50000})/);
            text = matches[0];
            this.wordCount = 50000;
          }
          else {
            this.wordCount = this.origWordCount;
          }

          return text;
        },

        // Main extraction method using provided file type handler
        async extractText(file, handler) {
          this.progress = 0;
          this.statusText = `Loading ${handler.displayName}...`;
          this.processing = true;
          this.error = '';

          const progressCallback = (progress, status) => {
            this.progress = progress;
            this.statusText = status;
          };

          let fullText = await handler.extract(file, progressCallback);

          progressCallback(100, 'Text extraction complete!');
          this.processing = false;

          const fileName = file.name.toLowerCase();
          this.openDocumentModal(fileName, fullText);
        },

        clearFile() {
          this.tutor.document_filename = '';
          this.tutor.document_text = '';
          this.clearState();

          // Clear the file input
          const fileInput = this.$el.querySelector('input[type="file"]');
          if (fileInput) fileInput.value = '';
        },

        clearState() {
          this.processing = false;
          this.error = '';
          this.statusText = '';
          this.progress = 0;
        },

        openDocumentModal(fileName, textToEdit) {
          this.editingFilename = fileName;

          // Process the extracted text (count words, truncate)
          const processedText = this.processDocumentText(textToEdit);

          this.$refs.document_text_editor.textContent = processedText;
          this.$refs.document_text_modal.showModal();
        },

        saveDocument() {
          this.$refs.document_text_modal.close();
          this.clearState();
          // Process the potentially-edited text (count words, truncate)
          const editedText = this.$refs.document_text_editor.textContent;
          const processedText = this.processDocumentText(editedText);
          // Save it into the tutor state
          this.tutor.document_text = processedText;
          this.tutor.document_filename = this.editingFilename;
        },
      }));
    });
  </script>
{% endblock extrahead %}

{% block body %}
<section class="section" x-data='tutor_editor()'>
  <div class="container">
    {% if item.row_id %}
      {# We're editing an existing tutor. #}
      <h1 class="title">Editing focused tutor '{{ item.name }}' in class '{{ auth.cur_class.class_name }}'</h1>
      {% set form_save_action = url_for(".update_item", item_id=item.row_id) %}
    {% else %}
      <h1 class="title">Create a focused tutor for guided chats in class '{{ auth.cur_class.class_name }}'</h1>
      {% set form_save_action = url_for(".create_item") %}
    {% endif %}
    <form x-ref="tutor_form" class="wide-labels" method="post" enctype="multipart/form-data">

      {% if item.row_id %}
        {# We're editing an existing tutor; pass that back in any updated so the cache is used. #}
        <input type="hidden" name="row_id" value="{{ item.row_id }}">
      {% endif %}

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label" for="name">Name</label>
          <p class="help-text">What students will see when selecting a tutor.</p>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control">
              <input class="input" name="name" id="name" required x-bind:disabled="loading" x-model="tutor.name">
            </div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label" for="topic">Topic or Focus</label>
          <p class="help-text">What should this tutor cover?</p>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control">
              <input class="input" name="topic" id="topic" required x-bind:disabled="loading" x-model="tutor.topic">
            </div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label" for="context">Learning context</label>
          <p class="help-text">Briefly describe the class or other context.<br>E.g.: "A college CS 1 course using Python"</p>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control">
              <input class="input" name="context" id="context" required x-bind:disabled="loading" x-model="tutor.context">
            </div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal" x-data="docUploader()">
        <input type="hidden" name="document_filename" x-model="tutor.document_filename">
        <input type="hidden" name="document_text" x-model="tutor.document_text">
        <div class="field-label is-normal">
          <label class="label">Context document (optional)</label>
          <p class="help-text">You may upload a PDF or DOCX file or paste text with additional context for generating objectives and questions (e.g., lecture notes, a book chapter, or an assignment).<br>Text will be extracted in your browser.<br>Max extracted text: 50,000 words.</p>
        </div>

        <div class="field-body">
          <!-- Show existing document if there is one -->
          <div class="field is-grouped" x-show="tutor.document_filename" x-cloak>
            <div class="control">
              <p class="mt-2">
              Using: <strong x-text="tutor.document_filename"></strong> <em class="mx-2" x-text="`(${wordCount} words)`"></em>
              </p>
            </div>
            <div class="control">
              <button class="button is-rounded is-info is-outlined is-small mt-1" type="button" @click="openDocumentModal(tutor.document_filename, tutor.document_text)">
                View/edit text
              </button>
            </div>
            <div class="control">
              <button
                  class="button is-rounded is-danger is-outlined is-small mt-1"
                  type="button"
                  @click="clearFile()"
                  x-bind:disabled="loading"
                  >
                  <span class="delete mr-2"></span>
                  Remove document
              </button>
            </div>
          </div>

          <!-- Show file upload when no document -->
          <div class="field" x-show="!tutor.document_filename" x-cloak>
            <div class="control file has-name">
              <label class="file-label">
                <input class="file-input" type="file" accept=".pdf,.docx" x-bind:disabled="loading || processing" @change="handleFileSelect($event)">
                <span class="file-cta">
                  Choose a PDF or DOCXâ€¦
                </span>
                <span class="file-name" x-text="tutor.document_filename || 'No file chosen'">
                  No file chosen
                </span>
              </label>
            </div>
            <p class="m-2"><em>or</em></p>
            <div class="control">
              <button type="button" class="button" @click="openDocumentModal('Pasted text', '');">Paste text</button>
            </div>

            <!-- Progress bar -->
            <div x-show="processing" class="control mt-2">
              <progress class="progress is-primary mb-2" x-bind:value="progress" max="100">
                <span x-text="progress + '%'"></span>
              </progress>
              <p class="help-text" x-text="statusText"></p>
            </div>

            <!-- Error display -->
            <div x-show="error" class="control mt-2">
              <div class="notification is-danger is-light" @click="clearState()">
                <button class="delete" type="button"></button>
                <span x-text="error"></span>
              </div>
            </div>

          </div>
        </div>

        <dialog x-ref="document_text_modal" style="width: 60%; max-width: 80em; min-width: min(50em, 100vw);">
          <div class="content box">
            <h3 x-text="editingFilename"></h3>
            <p x-show="origWordCount > 0" class="help">
              <span x-text="wordCount"></span> words
              <span x-show="origWordCount > 50000" class="has-text-danger ml-1">(<span x-text="origWordCount"></span> extracted words exceeded 50000 word limit &mdash; text was truncated)</span>
            </p>
            <pre
              style="white-space: pre-wrap; height: 60vh; overflow-y: auto;"
              contenteditable="true"
              x-ref="document_text_editor"
            ></pre>
            <div class="field is-grouped">
              <div class="control">
                <button class="button is-link" type="button" @click="saveDocument()">Save</button>
              </div>
              <div class="control">
                <button class="button" type="button" @click="$event.target.closest('dialog').close()">Cancel</button>
              </div>
            </div>
          </div>
        </dialog>
      </div>

      <hr>

      <div class="field is-horizontal">
        <div class="field-label is-normal"><!-- spacing --></div>
        <div class="field-body">
          <div class="field is-grouped is-flex-wrap-wrap">
            <div class="control">
              <button
                class="button"
                type="button"
                id="gen_objectives"
                :class="[hasObjectives ? 'is-warning' : 'is-link', loading === 'objectives' && 'is-loading']"
                :disabled="loading && loading !== 'objectives'"
                @click="generateObjectives"
              >
                <span x-text="hasObjectives ? 'Regenerate' : 'Generate'"></span>
                <span class="icon">
                  <svg aria-hidden="true"><use href="#svg_corner_right_down" /></svg>
                </span>
              </button>
            </div>
            <div class="control">
              <input name="num_objectives" required class="input" type="number" min=1 size="1" style="width: 4em;" x-data="{num_objectives: $persist(5)}" x-model="num_objectives">
            </div>
            <div class="control pt-2">
              draft learning objectives.
            </div>
            <div x-show="hasObjectives" class="help-text ml-2 pt-3 is-size-7 is-italic">This will overwrite existing objectives and questions.</div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label" for="objectives"><h2 class="title is-size-5">Learning Objectives</h2></label>
        </div>
        <div class="field-body">
          <div class="content">
            <p class="pt-2" x-show="!hasObjectives"><i>Nothing yet.</i></p>
            <div class="box pt-1" x-show="hasObjectives">
              <ol>
                <template x-for="obj in tutor.objectives">
                  <div>
                    <input type="hidden" name="objectives" x-model="obj.name">
                    <li class="mt-3" x-html="render(obj.name)"></li>
                  </div>
                </template>
              </ol>
              <button class="button is-link is-outlined ml-4" type="button" @click="openItemEditor(tutor.objectives, 'Learning Objectives', true)">
                Edit objectives
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal" x-show="hasObjectives">
        <div class="field-label is-normal"><!-- spacing --></div>
        <div class="field-body">
          <div class="field is-grouped is-flex-wrap-wrap">
            <div class="control">
              <button
                class="button"
                type="button"
                id="gen_questions"
                :class="[hasQuestions ? 'is-warning' : 'is-link', loading === 'questions' && 'is-loading']"
                :disabled="loading && loading !== 'questions'"
                @click="generateQuestions"
              >
                <span x-text="hasQuestions ? 'Regenerate' : 'Generate'"></span>
                <span class="icon">
                  <svg aria-hidden="true"><use href="#svg_corner_right_down" /></svg>
                </span>
              </button>
            </div>
            <div class="control">
              <input name="num_questions" required class="input" type="number" min=1 size="1" style="width: 4em;" x-data="{num_questions: $persist(3)}" x-model="num_questions">
            </div>
            <div class="control pt-2">
              draft questions per objective.
            </div>
            <div x-show="hasQuestions" class="help-text ml-2 pt-3 is-size-7 is-italic">This will overwrite existing questions.</div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <h2 class="title is-size-5">Tutor Plan</h2>
        </div>
        <div class="field-body">
          <div class="content">
            <p class="pt-2" x-show="!hasObjectives"><i>Nothing yet.</i></p>
            <template x-for="(obj, index) in tutor.objectives">
              <div class="box">
                <h3 class="is-size-6" x-text="`${index + 1}. ${obj.name}`"></h3>
                <ol>
                  <template x-for="question in obj.questions">
                    <div>
                      <input type="hidden" x-bind:name="`questions[${index}]`" x-model="question">
                      <li class="mt-3" x-html="render(question)"></li>
                    </div>
                  </template>
                </ol>
                <button class="button is-link is-outlined ml-4" type="button" @click="openItemEditor(obj.questions, obj.name, false)">
                  Edit questions
                </button>
              </div>
            </template>
          </div>
        </div>
      </div>

      <div class="field is-horizontal mt-5">
        <div class="field-label is-normal"><!-- spacing --></div>
        <div class="field-body">
          <div class="field is-grouped">
            <div class="control">
              <button class="button is-link" type="submit" :disabled="loading || !hasQuestions" formaction="{{ form_save_action }}">
                Save Tutor
              </button>
            </div>
            <div class="control">
              <button class="button is-light" type="button" @click="reset_form">
                Start Over
              </button>
            </div>
          </div>
        </div>
      </div>

    </form>

    <!-- Item Editor Modal -->
    <dialog x-ref="itemEditorModal" style="min-height: 75vh; width: 60%; max-width: 80em; min-width: min(50em, 100vw);" @close="resetItemEditor">
      <template x-if="tempItems !== null">
        <div class="content box">
          <h3 x-text="editTitle"></h3>
          <div class="field">
            <template x-for="(item, index) in tempItems">
              <div x-bind:draggable="drag_index === index" @dragstart="dragstart(index, $event)" @dragend="dragend" @dragenter="dragenter(index)" class="mt-2" style="display: flex; gap: 0.5em; align-items: center;">
                <span data-drag-handle @mousedown="drag_index = index" @mouseup="drag_index = null" style="cursor: move; vertical-align: middle; text-align: center;" title="drag to reorder">
                  <svg aria-hidden="true" class="icon is-small mt-1"><use href="#svg_grip" /></svg>
                </span>
                <button type="button" class="delete" title="delete item" @click="tempItems.splice(index, 1)"></button>
                <div class="control is-flex-grow-1">
                  <template x-if="editingObjectives">
                    <input class="input" x-model="tempItems[index].name">
                  </template>
                  <template x-if="!editingObjectives">
                    <textarea class="textarea" x-model="tempItems[index]" rows=3></textarea>
                  </template>
                </div>
              </div>
            </template>
          </div>
          <div class="field">
            <div class="control">
              <button type="button" class="button" @click="tempItems.push(editingObjectives ? { ...objectiveTemplate } : '')">+ add an item</button>
            </div>
          </div>
          <div class="field is-grouped">
            <div class="control">
              <button class="button is-link" type="button" @click="saveItems()">Update</button>
            </div>
            <div class="control">
              <button class="button" type="button" @click="$refs.itemEditorModal.close()">Cancel</button>
            </div>
          </div>
        </div>
      </template>
    </dialog>

  </div>
</section>

{% endblock body %}
