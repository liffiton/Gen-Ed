{% extends "base.html" %}

{% block extrahead %}
  <script type="module">
    // For rendering questions
    import markdownIt from 'https://cdn.jsdelivr.net/npm/markdown-it@14/+esm';
    const md = markdownIt();

    document.addEventListener('alpine:init', () => {
      const orig_tutor = {{ item | tojson }};
      Alpine.data('tutor_editor', () => ({
        tutor: null,
        loading: null,
        objectiveNames: "",

        init() {
          // Do one-way model updates *to* objectiveNames, so user can still edit the list (for regenerating questions)
          this.$watch('tutor', newVal => this.objectiveNames = newVal.objectives.map(obj => obj.name).join('\n'));
          this.reset_form();
        },
        reset_form() {
          this.tutor = structuredClone(orig_tutor);
        },

        render(question) {
          return md.render(question);
        },

        get hasObjectives() {
          return this.objectiveNames;
        },
        get hasQuestions() {
          return this.hasObjectives && this.tutor.objectives.some(obj => obj.questions.length);
        },

        async generateObjectives() {
          const form = this.$refs.tutor_form;

          // validate and report issues in form (if any) before proceeding
          if (!form.reportValidity()) {
            return;
          }

          this.loading = 'objectives';
          try {
            // build formdata to send via fetch
            const formData = new URLSearchParams(new FormData(form));

            // start the request
            const response = await fetch('{{ url_for('class_config.table.guided.generate_objectives') }}', {
              method: 'POST',
              body: formData,
            });

            if (!response.ok) {
              const text = await response.text();
              alert(`An error occurred: ${text}`);
              return;
            }

            const newObjectives = await response.json();
            this.tutor.objectives = newObjectives;
          } catch (error) {
            alert(`An error occurred: ${error}`);
          } finally {
            this.loading = null;
          }
        },

        async generateQuestions() {
          const form = this.$refs.tutor_form;

          // validate and report issues in form (if any) before proceeding
          if (!form.reportValidity()) {
            return;
          }

          this.loading = 'questions';
          try {
            // build formdata to send via fetch
            const formData = new URLSearchParams(new FormData(form));

            // start the request
            const response = await fetch('{{ url_for('class_config.table.guided.generate_questions') }}', {
              method: 'POST',
              body: formData,
            });

            if (!response.ok) {
              const text = await response.text();
              alert(`An error occurred: ${text}`);
              return;
            }

            const newQuestions = await response.json();
            this.tutor.objectives = newQuestions;
          } catch (error) {
            alert(`An error occurred: ${error}`);
          } finally {
            this.loading = null;
          }
        },
      }));

      Alpine.data('question_editor', (objective_index) => ({
        questions: null,
        drag_index: null,

        init() {
          this.reset();
        },
        reset() {
          // get unlinked/unaliased copy of the parent objective's questions
          this.questions = Alpine.raw(this.tutor.objectives[objective_index].questions.slice());
        },
        updateParent() {
          // copy the edited questions back to the parent objective
          this.tutor.objectives[objective_index].questions = this.questions.slice();
        },
        dragstart(index, event) {
          // only allow drag if over the drag handle td
          const dragElement = event.target.querySelector("[data-drag-handle]");
          // use :hover match to detect if cursor is within the element
          if (dragElement === null || !dragElement.matches(":hover")) { event.preventDefault(); return; }
          this.drag_index = index;
        },
        dragenter(index) {
          if (this.drag_index === null || index === this.drag_index) { return; }
          const draggedItem = this.questions.splice(this.drag_index, 1)[0];
          this.questions.splice(index, 0, draggedItem);
          this.drag_index = index;
        },
        dragend() {
          if (this.drag_index === null) { return; }
          this.drag_index = null;
        },
      }));

      Alpine.data('pdfUploader', () => ({
        processing: false,
        progress: 0,
        statusText: '',
        error: '',
        wordCount: 0,
        isNewDocument: false,

        async handleFileSelect(event) {
          const file = event.target.files[0];
          if (!file) {
            this.clearFile();
            return;
          }

          this.tutor.document_filename = file.name;

          // Find the matching handler using destructuring assignment
          const fileName = file.name.toLowerCase();
          const entry = Object.entries(this.fileHandlers)
            .find(([ext, _handler]) => fileName.endsWith(ext));

          if (!entry) {
            this.clearFile();
            this.error = 'Unsupported file type. Please upload a PDF or DOCX file.';
            return;
          }

          const [_, handler] = entry;

          try {
            await this.extractText(file, handler);
          } catch (error) {
            this.error = `Failed to extract text from ${handler.displayName} file: ${error.message}`;
            console.error('Text extraction error:', error);
          }
        },

        // File type handlers using strategy pattern
        fileHandlers: {
          '.pdf': {
            displayName: 'PDF',
            extract: async (file, progressCallback) => {
              // Dynamically import PDF.js
              progressCallback(5, 'Loading PDF library...');
              pdfjsLib = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4/+esm');
              pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4/build/pdf.worker.min.mjs';

              const arrayBuffer = await file.arrayBuffer();
              progressCallback(15, 'Parsing PDF structure...');

              const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
              const numPages = pdf.numPages;

              let fullText = '';

              for (let i = 1; i <= numPages; i++) {
                progressCallback(15 + (i / numPages) * 75, 
                  `Extracting text from page ${i} of ${numPages}...`);

                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent({
                  normalizeWhitespace: true
                });

                // Simple approach: add line breaks based on hasEOL flag
                let pageText = '';
                for (const item of textContent.items) {
                  pageText += item.str;
                  if (item.hasEOL) {
                    pageText += '\n';
                  } else {
                    // Add space if the next item doesn't start immediately
                    pageText += ' ';
                  }
                }

                fullText += pageText + '\n\n';
              }

              return fullText;
            }
          },
          '.docx': {
            displayName: 'DOCX',
            extract: async (file, progressCallback) => {
              // Dynamically import mammoth.js
              progressCallback(5, 'Loading DOCX library...');
              const mammoth = await import('https://cdn.jsdelivr.net/npm/mammoth@1/+esm');

              progressCallback(30, 'Parsing DOCX structure...');

              const arrayBuffer = await file.arrayBuffer();
              const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });

              return result.value;
            }
          }
        },

        // Helper to process document text (count words, truncate, store)
        processDocumentText(rawText) {
          // Clean up the text
          let text = rawText.trim();

          // Count words
          this.wordCount = text.split(/\s+/).filter(word => word.length > 0).length;

          // Truncate if too long (50k words limit)
          if (this.wordCount > 50000) {
            const words = text.split(/\s+/);
            text = words.slice(0, 50000).join(' ');
            this.wordCount = 50000;
          }

          this.tutor.document_text = text;
        },

        // Main extraction method using provided file type handler
        async extractText(file, handler) {
          this.progress = 0;
          this.statusText = `Loading ${handler.displayName}...`;
          this.processing = true;
          this.error = '';

          const progressCallback = (progress, status) => {
            this.progress = progress;
            this.statusText = status;
          };

          let fullText = await handler.extract(file, progressCallback);

          progressCallback(80, 'Processing extracted text...');

          // Process the extracted text (count words, truncate)
          this.processDocumentText(fullText);

          progressCallback(100, 'Text extraction complete!');
          this.processing = false;

          this.isNewDocument = true;
          this.openDocumentModal();
        },

        clearFile() {
          this.tutor.document_filename = '';
          this.tutor.document_text = '';
          this.clearState();

          // Clear the file input
          const fileInput = this.$el.querySelector('input[type="file"]');
          if (fileInput) fileInput.value = '';
        },

        clearState() {
          this.processing = false;
          this.error = '';
          this.statusText = '';
          this.progress = 0;
        },

        openDocumentModal() {
          this.$refs.document_text_editor.textContent = this.tutor.document_text;
          document.getElementById('doc_text_modal').showModal();
        },

        saveDocument() {
          this.clearState();
          // Process the potentially-edited text (count words, truncate)
          this.processDocumentText(this.$refs.document_text_editor.textContent);
          document.getElementById('doc_text_modal').close();
        },

        rejectDocument() {
          this.clearFile();
          document.getElementById('doc_text_modal').close();
        }
      }));
    });
  </script>
{% endblock extrahead %}

{% block body %}
<section class="section" x-data='tutor_editor()'>
  <div class="container">
    {% if item.row_id %}
      {# We're editing an existing tutor. #}
      <h1 class="title">Editing focused tutor '{{ item.name }}' in class '{{ auth.cur_class.class_name }}'</h1>
      {% set form_save_action = url_for(".update_item", item_id=item.row_id) %}
    {% else %}
      <h1 class="title">Create a focused tutor for guided chats in class '{{ auth.cur_class.class_name }}'</h1>
      {% set form_save_action = url_for(".create_item") %}
    {% endif %}
    <form x-ref="tutor_form" class="wide-labels" method="post" enctype="multipart/form-data">

      {% if item.row_id %}
        {# We're editing an existing tutor; pass that back in any updated so the cache is used. #}
        <input type="hidden" name="row_id" value="{{ item.row_id }}">
      {% endif %}

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label" for="name">Name</label>
          <p class="help-text">What students will see when selecting a tutor.</p>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control">
              <input class="input" name="name" id="name" required x-bind:disabled="loading" x-model="tutor.name">
            </div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label" for="topic">Topic or Focus</label>
          <p class="help-text">What should this tutor cover?</p>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control">
              <input class="input" name="topic" id="topic" required x-bind:disabled="loading" x-model="tutor.topic">
            </div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label" for="context">Learning context</label>
          <p class="help-text">Briefly describe the class or other context.<br>E.g.: "A college CS 1 course using Python"</p>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control">
              <input class="input" name="context" id="context" required x-bind:disabled="loading" x-model="tutor.context">
            </div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal" x-data="pdfUploader()">
        <input type="hidden" name="document_filename" x-model="tutor.document_filename">
        <input type="hidden" name="document_text" x-model="tutor.document_text">
        <div class="field-label is-normal">
          <label class="label">Document (optional)</label>
          <p class="help-text">You may upload a PDF or DOCX file or paste text with additional context for generating objectives and questions (e.g., lecture notes, a book chapter, or an assignment).<br>Text will be extracted in your browser.<br>Max extracted text: 50,000 words.</p>
        </div>

        <div class="field-body">
          <!-- Show existing document if there is one -->
          <div class="field is-grouped" x-show="tutor.document_filename" x-cloak>
            <div class="control">
              <p class="mt-2">
              Using: <strong x-text="tutor.document_filename"></strong> <em class="mx-2" x-text="`(${wordCount} words)`"></em>
              </p>
            </div>
            <div class="control">
              <button class="button is-rounded is-info is-outlined is-small mt-1" type="button" @click="isNewDocument = false; openDocumentModal()">
                View/edit text
              </button>
            </div>
            <div class="control">
              <button
                  class="button is-rounded is-danger is-outlined is-small mt-1"
                  type="button"
                  @click="clearFile()"
                  x-bind:disabled="loading"
                  >
                  <span class="delete mr-2"></span>
                  Remove document
              </button>
            </div>
          </div>

          <!-- Show file upload when no document -->
          <div class="field" x-show="!tutor.document_filename" x-cloak>
            <div class="control file has-name">
              <label class="file-label">
                <input class="file-input" type="file" accept=".pdf,.docx" x-bind:disabled="loading || processing" @change="handleFileSelect($event)">
                <span class="file-cta">
                  Choose a PDF or DOCXâ€¦
                </span>
                <span class="file-name" x-text="tutor.document_filename || 'No file chosen'">
                  No file chosen
                </span>
              </label>
            </div>
            <p class="m-2"><em>or</em></p>
            <div class="control">
              <button type="button" class="button" @click="tutor.document_filename = 'Pasted text'; isNewDocument = true; openDocumentModal();">Paste text</button>
            </div>

            <!-- Progress bar -->
            <div x-show="processing" class="control mt-2">
              <progress class="progress is-primary mb-2" x-bind:value="progress" max="100">
                <span x-text="progress + '%'"></span>
              </progress>
              <p class="help-text" x-text="statusText"></p>
            </div>

            <!-- Error display -->
            <div x-show="error" class="control mt-2">
              <div class="notification is-danger is-light" @click="clearState()">
                <button class="delete" type="button"></button>
                <span x-text="error"></span>
              </div>
            </div>

          </div>
        </div>

        <dialog id="doc_text_modal" style="width: 60%; max-width: 80em; min-width: min(50em, 100vw);">
          <div class="content box">
            <h3 x-text="tutor.document_filename"></h3>
            <p x-show="isNewDocument && wordCount > 0" class="help">
              <span x-text="wordCount"></span> words extracted
              <span x-show="wordCount > 50000" class="has-text-danger ml-1">(exceeds 50,000 word limit - will be truncated)</span>
            </p>
            <pre
              style="white-space: pre-wrap; height: 60vh; overflow-y: auto;"
              contenteditable="true"
              x-ref="document_text_editor"
            ></pre>
            <div class="field is-grouped">
              <div class="control">
                <button class="button is-link" type="button" @click="saveDocument()">Save</button>
              </div>
              <div class="control">
                <button class="button" type="button" @click="isNewDocument && rejectDocument() || $event.target.closest('dialog').close()">Cancel</button>
              </div>
            </div>
          </div>
        </dialog>
      </div>

      <hr>

      <div class="field is-horizontal">
        <div class="field-label is-normal"><!-- spacing --></div>
        <div class="field-body">
          <div class="field is-grouped is-flex-wrap-wrap">
            <div class="control">
              <button
                class="button"
                type="button"
                id="gen_objectives"
                :class="[hasObjectives ? 'is-warning' : 'is-link', loading === 'objectives' && 'is-loading']"
                :disabled="loading && loading !== 'objectives'"
                @click="generateObjectives"
              >
                <span x-text="hasObjectives ? 'Regenerate' : 'Generate'"></span>
                <span class="icon">
                  <svg aria-hidden="true"><use href="#svg_corner_right_down" /></svg>
                </span>
              </button>
            </div>
            <div class="control">
              <input name="num_objectives" required class="input" type="number" min=1 size="1" style="width: 4em;" x-data="{num_objectives: $persist(5)}" x-model="num_objectives">
            </div>
            <div class="control pt-2">
              draft learning objectives.
            </div>
            <div x-show="hasObjectives" class="help-text ml-2 pt-3 is-size-7 is-italic">This will overwrite existing objectives and questions.</div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label" for="objectives"><h2 class="title is-size-5">Learning Objectives</h2></label>
        </div>
        <div class="field-body">
          <div class="field">
            <textarea class="textarea" name="objectives" id="objectives" x-model="objectiveNames"></textarea>
          </div>
        </div>
      </div>

      <div class="field is-horizontal" x-show="hasObjectives">
        <div class="field-label is-normal"><!-- spacing --></div>
        <div class="field-body">
          <div class="field is-grouped is-flex-wrap-wrap">
            <div class="control">
              <button
                class="button"
                type="button"
                id="gen_questions"
                :class="[hasQuestions ? 'is-warning' : 'is-link', loading === 'questions' && 'is-loading']"
                :disabled="loading && loading !== 'questions'"
                @click="generateQuestions"
              >
                <span x-text="hasQuestions ? 'Regenerate' : 'Generate'"></span>
                <span class="icon">
                  <svg aria-hidden="true"><use href="#svg_corner_right_down" /></svg>
                </span>
              </button>
            </div>
            <div class="control">
              <input name="num_questions" required class="input" type="number" min=1 size="1" style="width: 4em;" x-data="{num_questions: $persist(3)}" x-model="num_questions">
            </div>
            <div class="control pt-2">
              draft questions per objective.
            </div>
            <div x-show="hasQuestions" class="help-text ml-2 pt-3 is-size-7 is-italic">This will overwrite existing questions.</div>
          </div>
        </div>
      </div>

      <div class="field is-horizontal">
        <div class="field-label is-normal">
          <h2 class="title is-size-5">Tutor Plan</h2>
        </div>
        <div class="field-body">
          <div class="content">
            <p class="pt-2" x-show="!hasObjectives"><i>Nothing yet.</i></p>
            <template x-for="(obj, index) in tutor.objectives">
              <div class="box">
                <h3 class="is-size-6" x-text="`${index + 1}. ${obj.name}`"></h3>
                <ol>
                  <template x-for="question in obj.questions">
                    <div>
                      <input type="hidden" x-bind:name="`questions[${index}]`" x-model="question">
                      <li class="mt-3" x-html="render(question)"></li>
                    </div>
                  </template>
                </ol>
                <button class="button is-link is-light ml-4" type="button" @click="$dispatch('opendialog'); document.getElementById(`q_dialog_${index}`).showModal()">
                  Edit questions
                </button>

                <template x-data='question_editor(index)' x-teleport="body" @opendialog.window="reset">
                  <dialog x-bind:id="`q_dialog_${index}`" style="min-height: 75vh; width: 60%; max-width: 80em; min-width: min(50em, 100vw);" @click="dialogCloseIfOutside" @close="reset">
                    <div class="content box">
                      <h3 x-text="obj.name"></h3>
                      <div class="field">
                        <div class="label">Questions</div>
                        <template x-for="(question, index) in questions">
                          <div x-bind:draggable="drag_index === index" @dragstart="dragstart(index, $event)" @dragend="dragend" @dragenter="dragenter(index)" class="mt-2" style="display: flex; gap: 0.5em; align-items: center;">
                            <span data-drag-handle @mousedown="drag_index = index" @mouseup="drag_index = null" style="cursor: move; vertical-align: middle; text-align: center;" title="drag to reorder">
                              <svg aria-hidden="true" class="icon is-small mt-1"><use href="#svg_grip" /></svg>
                            </span>
                            <button type="button" class="delete" title="delete question" @click="questions.splice(index, 1)"></button>
                            <div class="control is-flex-grow-1">
                              <textarea class="textarea" name="questions[]" x-model="questions[index]" rows=3 ></textarea>
                            </div>
                          </div>
                        </template>
                      </div>
                      <div class="field">
                        <div class="control">
                          <button type="button" class="button" @click="questions.push('')">+ add a question</button>
                        </div>
                      </div>
                      <div class="field is-grouped">
                        <div class="control">
                          <button class="button is-link" type="button" @click="updateParent(); $event.target.closest('dialog').close()">Update</button>
                        </div>
                        <div class="control">
                          <button class="button" type="button" @click="reset(); $event.target.closest('dialog').close()">Cancel</button>
                        </div>
                      </div>
                    </div>
                  </dialog>
                </template>

              </div>
            </template>
          </div>
        </div>
      </div>

      <div class="field is-horizontal mt-5">
        <div class="field-label is-normal"><!-- spacing --></div>
        <div class="field-body">
          <div class="field is-grouped">
            <div class="control">
              <button class="button is-link" type="submit" :disabled="loading || !hasQuestions" formaction="{{ form_save_action }}">
                Save Tutor
              </button>
            </div>
            <div class="control">
              <button class="button is-light" type="button" @click="reset_form">
                Start Over
              </button>
            </div>
          </div>
        </div>
      </div>

    </form>

  </div>
</section>

{% endblock body %}
